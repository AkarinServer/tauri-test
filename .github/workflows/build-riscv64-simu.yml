name: Build RISCV64 (Simulation)

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-riscv64:
    name: Build for RISCV64 Linux (Simulated)
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for version calculation

      - name: Setup Node.js (for version calculation)
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Calculate version
        id: version
        run: |
          # Calculate version based on commit count (自动版本递增)
          # Format: 0.1.${COMMIT_COUNT}
          BASE_VERSION="0.1"
          COMMIT_COUNT=$(git rev-list --count HEAD)
          VERSION="${BASE_VERSION}.${COMMIT_COUNT}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION (based on commit count: $COMMIT_COUNT)"
          
          # Update package.json and Cargo.toml with new version (构建前更新版本)
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '$VERSION';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
            console.log('Updated package.json version to', pkg.version);
          "
          
          # Update Cargo.toml version
          sed -i "s/^version = \".*\"/version = \"$VERSION\"/" src-tauri/Cargo.toml
          echo "Updated Cargo.toml version to $VERSION"
          
          # Update tauri.conf.json version (required for correct package naming)
          node -e "
            const fs = require('fs');
            const tauriConfig = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
            tauriConfig.version = '$VERSION';
            fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(tauriConfig, null, 2) + '\n');
            console.log('Updated tauri.conf.json version to', tauriConfig.version);
          "

      - name: Cache Cargo registry (for QEMU container)
        uses: actions/cache@v4
        with:
          path: |
            .cache/cargo-registry
            .cache/cargo-git
          key: simu-cargo-registry-riscv64-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            simu-cargo-registry-riscv64-

      - name: Cache Cargo target (for QEMU container)
        uses: actions/cache@v4
        with:
          path: |
            .cache/cargo-target
          key: simu-cargo-target-riscv64-fast-release-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            simu-cargo-target-riscv64-fast-release-

      - name: Cache node_modules (for QEMU container)
        uses: actions/cache@v4
        with:
          path: |
            .cache/node-modules
            .cache/npm
          key: simu-node-modules-riscv64-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            simu-node-modules-riscv64-

      - name: Cache sccache (for QEMU container)
        uses: actions/cache@v4
        with:
          path: |
            .cache/sccache
          key: simu-sccache-riscv64-${{ runner.os }}
          restore-keys: |
            simu-sccache-riscv64-

      - name: Build on RISCV64
        uses: uraimo/run-on-arch-action@v3
        with:
          arch: riscv64
          distro: ubuntu24.04
          githubToken: ${{ secrets.GITHUB_TOKEN }}
          dockerRunArgs: |
            --volume "${{ github.workspace }}:/workspace"
            --volume "${{ github.workspace }}/.cache:/cache"
          run: |
            # 更新系统（在容器中通常以 root 运行，不需要 sudo）
            # 添加重试机制，处理 Ubuntu 镜像同步问题
            apt-get update || {
              echo "警告: apt-get update 失败，等待 5 秒后重试..."
              sleep 5
              apt-get update || {
                echo "警告: 第二次重试失败，使用 --fix-missing 继续"
                apt-get update --fix-missing || true
              }
            }
            
            # 安装系统依赖
            apt-get install -y \
              libwebkit2gtk-4.1-dev \
              build-essential \
              curl \
              wget \
              file \
              libxdo-dev \
              libssl-dev \
              libayatana-appindicator3-dev \
              librsvg2-dev \
              pkg-config \
              ca-certificates \
              gnupg \
              git
            
            # 安装 Node.js (从 gounthar/unofficial-builds GitHub Releases 下载)
            # 参考: https://github.com/gounthar/unofficial-builds/releases/tag/v24.11.0
            # 这个源提供了 Node.js 24.11.0 的 RISCV64 原生构建
            NODE_VERSION="24.11.0"
            NODE_ARCH="riscv64"
            NODE_DIST="node-v${NODE_VERSION}-linux-${NODE_ARCH}"
            NODE_URL="https://github.com/gounthar/unofficial-builds/releases/download/v${NODE_VERSION}/${NODE_DIST}.tar.xz"
            
            # 下载并安装 Node.js
            cd /tmp
            echo "正在从 GitHub Releases 下载 Node.js ${NODE_VERSION} for RISCV64..."
            wget -q "$NODE_URL" -O "${NODE_DIST}.tar.xz" || {
              echo "错误: 无法下载 Node.js ${NODE_VERSION} for RISCV64 from GitHub Releases"
              exit 1
            }
            
            tar -xf "${NODE_DIST}.tar.xz"
            mv "${NODE_DIST}" /opt/nodejs
            export PATH="/opt/nodejs/bin:$PATH"
            ln -sf /opt/nodejs/bin/node /usr/local/bin/node
            ln -sf /opt/nodejs/bin/npm /usr/local/bin/npm
            ln -sf /opt/nodejs/bin/npx /usr/local/bin/npx
            
            # 验证安装
            node --version
            npm --version
            
            # 设置缓存目录
            mkdir -p /cache/cargo-registry /cache/cargo-git /cache/cargo-target /cache/node-modules /cache/npm /cache/sccache
            
            # 安装 Rust
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            source $HOME/.cargo/env
            
            # 添加 RISCV64 目标（虽然已经在 RISCV64 上，但确保工具链完整）
            rustup target add riscv64gc-unknown-linux-gnu
            
            # 配置 Cargo 使用缓存目录
            export CARGO_HOME=/cache/cargo-home
            mkdir -p $CARGO_HOME
            # 链接缓存的 registry 和 git
            if [ -d /cache/cargo-registry ] && [ "$(ls -A /cache/cargo-registry 2>/dev/null)" ]; then
              ln -sf /cache/cargo-registry $CARGO_HOME/registry || true
            fi
            if [ -d /cache/cargo-git ] && [ "$(ls -A /cache/cargo-git 2>/dev/null)" ]; then
              ln -sf /cache/cargo-git $CARGO_HOME/git || true
            fi
            
            # 安装 sccache for RISC-V
            echo "Installing sccache for RISC-V..."
            # Try to use pre-built binary if available, otherwise build from source
            if command -v cargo &> /dev/null; then
              # Build sccache from source for RISC-V
              # This may take some time but ensures compatibility
              cargo install sccache --locked --target riscv64gc-unknown-linux-gnu || {
                echo "Warning: Failed to install sccache, continuing without it"
                export RUSTC_WRAPPER=""
              }
              if command -v sccache &> /dev/null; then
                export RUSTC_WRAPPER=sccache
                export SCCACHE_DIR=/cache/sccache
                sccache --start-server || true
                echo "sccache installed and configured"
                sccache --show-stats || true
              fi
            fi
            
            # 配置 Cargo 环境变量（启用增量编译，已在 Cargo.toml 中配置）
            # 不再禁用增量编译，使用 Cargo.toml 中的配置
            # Note: CARGO_TARGET_DIR should be in workspace for Tauri to find it
            # We'll restore cached target directory before build
            export CARGO_BUILD_JOBS=$(nproc || echo 4)
            export CARGO_TERM_PROGRESS_WHEN=always
            export CARGO_TERM_PROGRESS_WIDTH=80
            export CARGO_NET_RETRY=10
            export CARGO_HTTP_TIMEOUT=300
            
            # 安装项目依赖
            # 切换到工作目录
            cd /workspace
            echo "当前工作目录: $(pwd)"
            ls -la
            
            # 恢复缓存的 target 目录（如果存在）
            if [ -d /cache/cargo-target ] && [ "$(ls -A /cache/cargo-target 2>/dev/null)" ]; then
              echo "Found cached target directory, restoring..."
              mkdir -p src-tauri/target
              # Copy cached target, but be careful not to overwrite existing files
              rsync -a /cache/cargo-target/ src-tauri/target/ || cp -r /cache/cargo-target/* src-tauri/target/ 2>/dev/null || true
              echo "Target directory restored from cache"
            fi
            
            # 配置 npm 使用缓存
            export npm_config_cache=/cache/npm
            mkdir -p $npm_config_cache
            
            # 如果缓存中有 node_modules，先尝试使用
            if [ -d /cache/node-modules ] && [ "$(ls -A /cache/node-modules 2>/dev/null)" ]; then
              echo "Found cached node_modules, copying..."
              cp -r /cache/node-modules /workspace/node_modules || true
            fi
            
            # Try to install dependencies normally first
            # vite.config.ts has conditional loading that will use Babel on RISC-V
            # If @swc/core installation fails, we'll remove it and retry
            INSTALL_FAILED=false
            if [ -f package-lock.json ]; then
              echo "找到 package-lock.json，使用 npm ci"
              npm ci --cache $npm_config_cache || INSTALL_FAILED=true
            else
              echo "警告: package-lock.json 不存在，使用 npm install"
              npm install --cache $npm_config_cache || INSTALL_FAILED=true
            fi
            
            # If installation failed, try removing @vitejs/plugin-react-swc and retry
            if [ "$INSTALL_FAILED" = true ]; then
              echo "Warning: Installation failed, likely due to @swc/core on RISC-V"
              echo "Removing @vitejs/plugin-react-swc and retrying..."
              if [ -f package.json ]; then
                node -e "
                  const fs = require('fs');
                  const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                  if (pkg.devDependencies && pkg.devDependencies['@vitejs/plugin-react-swc']) {
                    delete pkg.devDependencies['@vitejs/plugin-react-swc'];
                    fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
                    console.log('Removed @vitejs/plugin-react-swc from package.json');
                  }
                "
                # Remove from package-lock.json if it exists
                if [ -f package-lock.json ]; then
                  npm ci --cache $npm_config_cache || npm install --cache $npm_config_cache
                else
                  npm install --cache $npm_config_cache
                fi
              fi
            fi
            
            # 保存 node_modules 到缓存
            if [ -d /workspace/node_modules ]; then
              echo "Saving node_modules to cache..."
              rm -rf /cache/node-modules
              cp -r /workspace/node_modules /cache/node-modules || true
            fi
            
            # Ensure @vitejs/plugin-react is installed (Babel-based)
            # vite.config.ts will use this on RISC-V even if SWC plugin is installed
            if ! npm list @vitejs/plugin-react >/dev/null 2>&1; then
              echo "Installing @vitejs/plugin-react..."
              npm install --save-dev @vitejs/plugin-react
            fi
            
            # Note: vite.config.ts will automatically use Babel on RISC-V
            # even if @vitejs/plugin-react-swc is installed
            echo "Dependencies installed. vite.config.ts will handle SWC/Babel selection based on architecture."
            
            # 运行 prebuild
            npm run prebuild || echo "Warning: prebuild failed, continuing..."
            
            # 构建 Tauri 应用（使用 deb 和 rpm bundles，fast-release profile）
            # Note: Tauri's beforeBuildCommand will build frontend automatically
            echo "Starting Tauri build for RISC-V (Simulation)..."
            echo "Build will use fast-release profile (optimized for speed)"
            echo "Using incremental compilation (enabled in Cargo.toml)"
            if [ -n "$RUSTC_WRAPPER" ]; then
              echo "Using sccache for compilation caching"
              sccache --show-stats || true
            fi
            npm run tauri build -- --target riscv64gc-unknown-linux-gnu --bundles deb,rpm -- --profile fast-release
            
            # 显示 sccache 统计信息
            if [ -n "$RUSTC_WRAPPER" ]; then
              echo "sccache statistics after build:"
              sccache --show-stats || true
            fi
            
            # 保存 Cargo registry 和 git 到缓存
            if [ -d $CARGO_HOME/registry ]; then
              echo "Saving Cargo registry to cache..."
              mkdir -p /cache/cargo-registry
              cp -r $CARGO_HOME/registry/* /cache/cargo-registry/ 2>/dev/null || true
            fi
            if [ -d $CARGO_HOME/git ]; then
              echo "Saving Cargo git to cache..."
              mkdir -p /cache/cargo-git
              cp -r $CARGO_HOME/git/* /cache/cargo-git/ 2>/dev/null || true
            fi
            
            # 保存 target 目录到缓存
            if [ -d src-tauri/target ]; then
              echo "Saving target directory to cache..."
              mkdir -p /cache/cargo-target
              rsync -a src-tauri/target/ /cache/cargo-target/ || cp -r src-tauri/target/* /cache/cargo-target/ 2>/dev/null || true
              echo "Target directory saved to cache"
            fi
            
            # Verify build output
            echo "Build output verification:"
            ls -la src-tauri/target/riscv64gc-unknown-linux-gnu/fast-release/ 2>/dev/null || echo "Fast-release directory not found"
            ls -la src-tauri/target/riscv64gc-unknown-linux-gnu/fast-release/bundle/ 2>/dev/null || echo "Bundle directory not found"
            ls -la src-tauri/target/riscv64gc-unknown-linux-gnu/release/ 2>/dev/null || echo "Release directory not found"
            
            # Fix file permissions so the host can rename files
            # Change ownership to match the runner user (usually UID 1001 or 1000)
            # Use chmod as a fallback to make files writable
            echo "Fixing file permissions for build artifacts..."
            chmod -R u+w src-tauri/target/riscv64gc-unknown-linux-gnu/fast-release/bundle/ 2>/dev/null || true
            chmod -R u+w src-tauri/target/riscv64gc-unknown-linux-gnu/release/bundle/ 2>/dev/null || true
            # Try to change ownership to a common user ID (1001 is typical for GitHub Actions)
            chown -R 1001:1001 src-tauri/target/riscv64gc-unknown-linux-gnu/fast-release/bundle/ 2>/dev/null || true
            chown -R 1001:1001 src-tauri/target/riscv64gc-unknown-linux-gnu/release/bundle/ 2>/dev/null || true

      - name: Save caches
        if: always()
        run: |
          # Save caches back to GitHub Actions cache
          # Note: The cache directories are already in .cache/ from the volume mount
          echo "Caches are saved in .cache/ directory for next run"

      - name: Fix file permissions
        run: |
          # Fix permissions for files created in Docker container
          # Try to get the current user ID
          USER_ID=$(id -u)
          echo "Current user ID: $USER_ID"
          
          RELEASE_DIR="src-tauri/target/riscv64gc-unknown-linux-gnu/fast-release"
          if [ ! -d "$RELEASE_DIR" ]; then
            RELEASE_DIR="src-tauri/target/riscv64gc-unknown-linux-gnu/release"
          fi
          
          if [ -d "$RELEASE_DIR/bundle" ]; then
            echo "Fixing permissions for bundle directory..."
            # Use sudo if available, otherwise try chmod
            if command -v sudo >/dev/null 2>&1; then
              sudo chown -R $USER_ID:$USER_ID "$RELEASE_DIR/bundle" || true
              sudo chmod -R u+w "$RELEASE_DIR/bundle" || true
            else
              chmod -R u+w "$RELEASE_DIR/bundle" 2>/dev/null || true
            fi
            echo "Permissions fixed"
            ls -la "$RELEASE_DIR/bundle/" 2>/dev/null || echo "Cannot list bundle directory"
          fi

      - name: Prepare and rename release files
        id: release_files
        run: |
          # Find all release files and rename with _s_linux_riscv64 suffix
          # Use fast-release directory first (since we use --profile fast-release)
          RELEASE_DIR="src-tauri/target/riscv64gc-unknown-linux-gnu/fast-release"
          
          # Fallback to release directory if fast-release doesn't exist
          if [ ! -d "$RELEASE_DIR" ]; then
            RELEASE_DIR="src-tauri/target/riscv64gc-unknown-linux-gnu/release"
          fi
          
          echo "Checking release directory: $RELEASE_DIR"
          ls -la "$RELEASE_DIR/" 2>/dev/null || echo "Release directory not found"
          ls -la "$RELEASE_DIR/bundle/" 2>/dev/null || echo "Bundle directory not found"
          
          # Create release files list
          RELEASE_FILES=()
          
          # Get current version for filtering
          CURRENT_VERSION="${{ steps.version.outputs.version }}"
          
          # Helper function to rename file with fallback to sudo
          rename_file() {
            local src="$1"
            local dst="$2"
            if mv "$src" "$dst" 2>/dev/null; then
              echo "✓ Renamed: $(basename "$src") -> $(basename "$dst")"
              return 0
            elif command -v sudo >/dev/null 2>&1 && sudo mv "$src" "$dst" 2>/dev/null; then
              echo "✓ Renamed (with sudo): $(basename "$src") -> $(basename "$dst")"
              return 0
            else
              echo "✗ Failed to rename: $(basename "$src")"
              return 1
            fi
          }
          
          # DEB packages - rename to RV.Verge_VERSION_s_linux_riscv64.deb
          if [ -d "$RELEASE_DIR/bundle/deb" ]; then
            for file in "$RELEASE_DIR/bundle/deb"/*.deb; do
              if [ -f "$file" ]; then
                FILENAME=$(basename "$file")
                # Check if file contains current version
                if echo "$FILENAME" | grep -Fq "_${CURRENT_VERSION}_"; then
                  DIR=$(dirname "$file")
                  # Rename: RV.Verge_VERSION_ARCH.deb -> RV.Verge_VERSION_s_linux_riscv64.deb
                  NEW_FILENAME=$(echo "$FILENAME" | sed -E "s/_([0-9]+\.[0-9]+\.[0-9]+)_([a-z0-9]+)\.deb$/_\\1_s_linux_riscv64.deb/")
                  NEW_FILE="$DIR/$NEW_FILENAME"
                  
                  if [ "$FILENAME" != "$NEW_FILENAME" ] && [ -f "$file" ]; then
                    if rename_file "$file" "$NEW_FILE"; then
                      RELEASE_FILES+=("$NEW_FILE")
                    else
                      # If rename failed, use the original file
                      RELEASE_FILES+=("$file")
                      echo "⚠ Using original filename: $FILENAME"
                    fi
                  else
                    RELEASE_FILES+=("$file")
                    echo "✓ Found DEB: $FILENAME"
                  fi
                else
                  echo "⚠ Skipping DEB with different version: $FILENAME"
                fi
              fi
            done
          else
            echo "✗ DEB directory not found: $RELEASE_DIR/bundle/deb"
          fi
          
          # RPM packages - rename to RV.Verge-VERSION-RELEASE.s.linux.riscv64.rpm
          if [ -d "$RELEASE_DIR/bundle/rpm" ]; then
            for file in "$RELEASE_DIR/bundle/rpm"/*.rpm; do
              if [ -f "$file" ]; then
                FILENAME=$(basename "$file")
                # Check if file contains current version
                if echo "$FILENAME" | grep -Fq "-${CURRENT_VERSION}-"; then
                  DIR=$(dirname "$file")
                  # Rename: RV.Verge-VERSION-RELEASE.ARCH.rpm -> RV.Verge-VERSION-RELEASE.s.linux.riscv64.rpm
                  # Pattern: .ARCH.rpm -> .s.linux.riscv64.rpm
                  NEW_FILENAME=$(echo "$FILENAME" | sed -E 's/\.([a-z0-9]+)\.rpm$/.s.linux.riscv64.rpm/')
                  NEW_FILE="$DIR/$NEW_FILENAME"
                  
                  if [ "$FILENAME" != "$NEW_FILENAME" ] && [ -f "$file" ]; then
                    if rename_file "$file" "$NEW_FILE"; then
                      RELEASE_FILES+=("$NEW_FILE")
                    else
                      # If rename failed, use the original file
                      RELEASE_FILES+=("$file")
                      echo "⚠ Using original filename: $FILENAME"
                    fi
                  else
                    RELEASE_FILES+=("$file")
                    echo "✓ Found RPM: $FILENAME"
                  fi
                else
                  echo "⚠ Skipping RPM with different version: $FILENAME"
                fi
              fi
            done
          else
            echo "✗ RPM directory not found: $RELEASE_DIR/bundle/rpm"
          fi
          
          # Check if files exist
          if [ ${#RELEASE_FILES[@]} -eq 0 ]; then
            echo "Error: No release files found!"
            echo "Build directory contents:"
            find "$RELEASE_DIR" -type f 2>/dev/null | head -20 || echo "Cannot list files"
            exit 1
          fi
          
          echo ""
          echo "Found ${#RELEASE_FILES[@]} release file(s):"
          for file in "${RELEASE_FILES[@]}"; do
            echo "  - $file ($(du -h "$file" | cut -f1))"
          done
          
          # Output files list (每行一个文件路径，使用multiline format)
          {
            echo "files<<EOF"
            printf '%s\n' "${RELEASE_FILES[@]}"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tauri-riscv64-simu
          path: |
            src-tauri/target/riscv64gc-unknown-linux-gnu/fast-release/bundle/
            src-tauri/target/riscv64gc-unknown-linux-gnu/release/bundle/

